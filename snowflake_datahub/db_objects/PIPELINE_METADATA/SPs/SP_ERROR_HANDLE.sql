CREATE OR REPLACE PROCEDURE DATAHUB.PIPELINE_METADATA.SP_ERROR_HANDLE("FILE_ID" NUMBER(38,0), "INGESTION_SRC_TYPE" VARCHAR)
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
    RES RESULTSET;
DATA_FEED_OBJECT OBJECT;
DDL_STATEMENT STRING;
COLUMN_DEFINITIONS ARRAY;
ELT_DATATYPE STRING := ''VARCHAR'';
STG_TABLE_PREFIX := ''STG_'';
ENTRY_COUNT INT;
ELT_COLUMN_LIST_STG ARRAY;
ELT_COLUMN_LIST_BRZ ARRAY;
EMAIL BOOLEAN := ''True'';
ERROR1 EXCEPTION (
        -20001,
        ''FILE_ID is having More than one entry in DATA_FEED_FILE_INVENTORY''
    );
    
BEGIN 
-- Check if DATA_TEST table has more than one entry for the given FILE_ID
    ENTRY_COUNT := (
        SELECT
            COUNT(*)
        FROM
            DATA_FEED_FILE_INVENTORY
        WHERE
            FILE_ID = :FILE_ID
            AND ACTIVE_FLG = ''Y''
    );
    
IF (:ENTRY_COUNT > 1) THEN 
    -- Construct the SQL query with the WHERE condition
    LET sql_query STRING := ''SELECT * FROM DATAHUB.PIPELINE_METADATA.DATA_FEED_FILE_INVENTORY WHERE FILE_ID = '' || :FILE_ID || 
 '' AND ACTIVE_FLG = ''''Y'''' '' ;
    
         -- CALL SP_EMAIL_NOTIFICATION (''bhavana.pichhika@osaic.com'',''ERROR'',''STRING'',''FILE_ID is having More than one entry in DATA_FEED_FILE_INVENTORY'');
         
            CALL SP_EMAIL_NOTIFICATION (''bhavana.pichhika@osaic.com'',''ERROR'',''SQL'',:sql_query);
         RAISE ERROR1;
END IF;
 

ELT_COLUMN_LIST_STG := ARRAY_CONSTRUCT(''PIPELINE_RUN_ID '' || :ELT_DATATYPE);
ELT_COLUMN_LIST_BRZ := ARRAY_CONSTRUCT(
    ''ELT_EXECUTION_DATE '' || :ELT_DATATYPE,
    ''ELT_SOURCE '' || :ELT_DATATYPE,
    ''ELT_LOAD_TYPE '' || :ELT_DATATYPE,
    ''ELT_PIPELINEKEY '' || :ELT_DATATYPE,
    ''ELT_COLUMNS_HASH '' || :ELT_DATATYPE,
    ''ELT_PRIMARY_KEY_HASH '' || :ELT_DATATYPE,
    ''ELT_FILE_ID '' || :ELT_DATATYPE,
    ''PIPELINE_RUN_ID '' || :ELT_DATATYPE
);
-- Truncate the ingestion table
DELETE FROM
    INGESTION_TABLE_SCHEMA
WHERE
    FILE_ID = :FILE_ID;
-- Fetch target table name and other details from DATA_FEED
SELECT
    OBJECT_CONSTRUCT(
        ''STG_SCHEMA_NAME'',
        STG_SCHEMA_NAME,
        ''STG_TABLE_NAME'',
        STG_TABLE_NAME,
        ''STG_DATABASE_NAME'',
        STG_DATABASE_NAME,
        ''TARGET_SCHEMA_NAME'',
        TARGET_SCHEMA_NAME,
        ''TARGET_TABLE_NAME'',
        TARGET_TABLE_NAME,
        ''COMMENTS_TEXT'',
        COMMENTS,
        ''CREATED_BY_NAME'',
        CREATED_BY_NAME
    ) INTO DATA_FEED_OBJECT
FROM
    DATA_FEED_FILE_INVENTORY
WHERE
    FILE_ID = :FILE_ID
    AND ACTIVE_FLG = ''Y'';
    
-- Extract values from the object
LET STG_SCHEMA_NAME STRING := DATA_FEED_OBJECT:STG_SCHEMA_NAME::STRING;
LET STG_TABLE_NAME STRING := DATA_FEED_OBJECT:STG_TABLE_NAME::STRING;
LET STG_DATABASE_NAME STRING := DATA_FEED_OBJECT:STG_DATABASE_NAME::STRING;
LET TARGET_SCHEMA_NAME STRING := DATA_FEED_OBJECT:TARGET_SCHEMA_NAME::STRING;
LET TARGET_TABLE_NAME STRING := DATA_FEED_OBJECT:TARGET_TABLE_NAME::STRING;
LET COMMENTS_TEXT STRING := DATA_FEED_OBJECT:COMMENTS_TEXT::STRING;
LET CREATED_BY_NAME STRING := DATA_FEED_OBJECT:CREATED_BY_NAME::STRING;
LET SOURCE_PRIMARYKEY STRING := DATA_FEED_OBJECT:SOURCE_PRIMARY_KEY::STRING;

IF (:INGESTION_SRC_TYPE = ''SQL'')  THEN -- Aggregate columns and table names into arrays
SELECT
    ARRAY_AGG(
        OBJECT_CONSTRUCT(
            ''COLUMN_NAME'',
            COLUMN_NAME,
            ''CONCATENATED_TABLE_NAME'',
            UPPER(
                TABLE_CATALOG || ''_'' || TABLE_SCHEMA || ''_'' || TABLE_NAME
            ),
            ''SQL_DATA_TYPE'',
            SQL_DATATYPE,
            ''COLUMN_ORDERS'',
            ORDINAL_POSITION,
            ''IS_NULLABLE'',
            CASE
                WHEN IS_NULLABLE = ''YES'' THEN ''Y''
                ELSE ''N''
            END
        )
    ) INTO COLUMN_DEFINITIONS
FROM
    SQL_SOURCE_MAPPING_DETAILS;
END IF;

-- Loop through each element in the array
FOR j IN 0 TO ARRAY_SIZE(COLUMN_DEFINITIONS) -1 DO LET COLUMN_NAME STRING := COLUMN_DEFINITIONS [j] :COLUMN_NAME;
LET CONCATENATED_TABLE_NAME STRING := COLUMN_DEFINITIONS [j] :CONCATENATED_TABLE_NAME;
LET SQL_DATA_TYPE STRING := COLUMN_DEFINITIONS [j] :SQL_DATA_TYPE;
LET COLUMN_ORDERS STRING := COLUMN_DEFINITIONS [j] :COLUMN_ORDERS;
LET IS_NULLABLE STRING := COLUMN_DEFINITIONS [j] :IS_NULLABLE;
-- Check if the concatenated table name matches the extracted table name
IF (STG_TABLE_PREFIX || :CONCATENATED_TABLE_NAME = :STG_TABLE_NAME) THEN -- Insert into FINAL table
INSERT INTO
    INGESTION_TABLE_SCHEMA (
        TABLE_SCHEMA_ID,
        DATABASE_NAME,
        STAGE_TABLE_SCHEMA,
        STAGE_TABLE_NAME,
        BRONZE_SCHEMA_NAME,
        BRONZE_TABLE_NAME,
        FILE_ID,
        COLUMN_NAME,
        COLUMN_DATATYPE_TEXT,
        COLUMN_COMMENT,
        NULLABLE_FLG,
        COLUMN_SEQUENCE_NUMBER,
        COLUMN_START_POSITION_NUMBER,
        COLUMN_END_POSITION_NUMBER,
        CASTING_LOGIC_TEXT,
        CASTING_DATE_FORMAT_TEXT,
        CREATED_BY_NAME,
        CREATED_TS
    )
VALUES
    (
        :FILE_ID,
        :STG_DATABASE_NAME,
        :STG_SCHEMA_NAME,
        :STG_TABLE_NAME,
        :TARGET_SCHEMA_NAME,
        :TARGET_TABLE_NAME,
        :FILE_ID,
        :COLUMN_NAME,
        :SQL_DATA_TYPE,
        :COMMENTS_TEXT,
        :IS_NULLABLE,
        :COLUMN_ORDERS,
        NULL,
        NULL,
        NULL,
        NULL,
        :CREATED_BY_NAME,
        CURRENT_TIMESTAMP
    );
END IF;
END FOR;
-- Aggregate column definitions into a single string for each table
SELECT
    ARRAY_AGG(COLUMN_NAME || '' '' || :ELT_DATATYPE) INTO COLUMN_DEFINITIONS
FROM
    INGESTION_TABLE_SCHEMA
WHERE
    FILE_ID = :FILE_ID;

BEGIN    

IF (:STG_SCHEMA_NAME = ''STAGING'') THEN DDL_STATEMENT := ''CREATE OR REPLACE TABLE '' || :STG_SCHEMA_NAME || ''.'' || :STG_TABLE_NAME || '' ('' || ARRAY_TO_STRING(COLUMN_DEFINITIONS, '', '') || '', '' || ARRAY_TO_STRING(ELT_COLUMN_LIST_STG, '', '') || '');'';
EXECUTE IMMEDIATE DDL_STATEMENT;
END IF;

EXCEPTION
    WHEN STATEMENT_ERROR THEN
                          
           LET STG_DDL_ERROR STRING := ''DDL is not generated. Error is ''||SQLERRM;             
           CALL SP_EMAIL_NOTIFICATION (''bhavana.pichhika@osaic.com'',''ERROR'',''SQL'',:STG_DDL_ERROR);                          
           RETURN ''Process failed in STAGE_TABLE DDL creation. ''|| :STG_DDL_ERROR;
END;

BEGIN
IF (:TARGET_SCHEMA_NAME = ''BRONZE'') THEN DDL_STATEMENT := ''CREATE OR REPLACE TABLE '' || :TARGET_SCHEMA_NAME || ''.'' || :TARGET_TABLE_NAME || '' ('' || ARRAY_TO_STRING(COLUMN_DEFINITIONS, '', '') || '', '' || ARRAY_TO_STRING(ELT_COLUMN_LIST_BRZ, '', '') || '');'';
EXECUTE IMMEDIATE DDL_STATEMENT;
END IF;

EXCEPTION
    WHEN STATEMENT_ERROR THEN
                          
           LET BRNZ_DDL_ERROR STRING := ''DDL is not generated. Error is ''||SQLERRM;             
           CALL SP_EMAIL_NOTIFICATION (''bhavana.pichhika@osaic.com'',''ERROR'',''SQL'',:BRNZ_DDL_ERROR);                         
           RETURN ''Process failed in STAGE_TABLE DDL creation. ''|| :BRNZ_DDL_ERROR;
END;

RETURN ''SUCCESS'';


END';