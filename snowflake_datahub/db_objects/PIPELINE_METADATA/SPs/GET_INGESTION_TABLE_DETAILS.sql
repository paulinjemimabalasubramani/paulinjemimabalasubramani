CREATE OR REPLACE PROCEDURE DATAHUB.PIPELINE_METADATA.GET_INGESTION_TABLE_DETAILS("FILE_ID" VARCHAR, "FILE_TYPE" VARCHAR)
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
MISSING_COLUMNSS STRING;
    res resultset;
    SQL_SOURCING_COLUMNS ARRAY;
     DATA_FEED_FILE_COLUMNS ARRAY;
    GET_SQL_COLUMNS ARRAY;
    COLUMN_COUNT NUMBER;
    Existing_column_count STRING;
    RECORD_EXISTS BOOLEAN;
    MISSING_COLUMNS STRING;
    DDL_STATEMENT STRING;
     TARGET_TABLE_NAME STRING;
     TARGET_SCHEMA_NAME STRING;
   
BEGIN

     -- Generate the sequence number once
  
    -- Step 1: Get all columns from SQL_SOURCING_MAPPING 
  SELECT ARRAY_AGG(
        OBJECT_CONSTRUCT(
            ''COLUMN_NAME'', 
            CASE
                WHEN COLUMN_NAME RLIKE ''^[0-9].*'' THEN
                    UPPER(''_'' || SPLIT(REGEXP_REPLACE(COLUMN_NAME, ''([0-9]+)([A-Z][a-z]+)'',''\\\\1 \\\\2''),'' '')[0] 
                        || ''_'' || REGEXP_REPLACE(SPLIT(REGEXP_REPLACE(COLUMN_NAME, ''([0-9]+)([A-Z][a-z]+)'',''\\\\1 \\\\2''),'' '')[1], ''([a-z])([A-Z])'', ''\\\\1_\\\\2''))
                ELSE
                    UPPER(REGEXP_REPLACE(COLUMN_NAME, ''([a-z])([A-Z])'', ''\\\\1_\\\\2''))
            END,
            ''CONCATENATED_TABLE_NAME'', UPPER(TABLE_CATALOG || ''_'' || TABLE_SCHEMA || ''_'' || TABLE_NAME),
            ''SQL_DATA_TYPE'', SQL_DATATYPE,
            ''COLUMN_ORDERS'', ORDINAL_POSITION,
            ''IS_NULLABLE'', CASE WHEN IS_NULLABLE = ''YES'' THEN ''Y'' ELSE ''N'' END
        )
    ) INTO SQL_SOURCING_COLUMNS  FROM SQL_SOURCE_MAPPING_DETAILS;


  
     
    -- Step 2: Get all columns from DATA_FEED_FILE_INVENTORY for the given FILE_ID
    SELECT ARRAY_AGG(
        OBJECT_CONSTRUCT(
            ''STG_SCHEMA_NAME'', STG_SCHEMA_NAME,
            ''STG_TABLE_NAME'', STG_TABLE_NAME,
            ''STG_DATABASE_NAME'', STG_DATABASE_NAME,
            ''TARGET_SCHEMA_NAME'', TARGET_SCHEMA_NAME,
            ''TARGET_TABLE_NAME'', TARGET_TABLE_NAME,
            ''COMMENTS'', COMMENTS,
            ''CREATED_BY_NAME'', CREATED_BY_NAME
        )
    )   INTO  DATA_FEED_FILE_COLUMNS
    FROM DATA_FEED_FILE_INVENTORY WHERE FILE_ID = :FILE_ID 
    AND ACTIVE_FLG =''Y'';

    -- Step 3: Combine SQL_SOURCING_COLUMNS and  DATA_FEED_FILE_COLUMNS into GET_SQL_COLUMNS
    GET_SQL_COLUMNS := ARRAY_CAT(SQL_SOURCING_COLUMNS,  DATA_FEED_FILE_COLUMNS);




    -- Step 4: Create the table GET_SQL_COLUMNS_DETAILS if it doesn''t exist
    CREATE OR REPLACE TABLE GET_SQL_COLUMNS_DETAILS (
        COLUMN_NAME STRING,
        CONCATENATED_TABLE_NAME STRING,
        SQL_DATA_TYPE STRING,
        COLUMN_ORDERS NUMBER,
        IS_NULLABLE STRING,
        STG_SCHEMA_NAME STRING,
        STG_TABLE_NAME STRING,
        STG_DATABASE_NAME STRING,
        TARGET_SCHEMA_NAME STRING,
        TARGET_TABLE_NAME STRING,
        COMMENTS STRING,
        CREATED_BY_NAME STRING
    );


    -- Step 5: Insert data into GET_SQL_COLUMNS_DETAILS table
    INSERT INTO GET_SQL_COLUMNS_DETAILS
    SELECT 
        VALUE:COLUMN_NAME::STRING AS COLUMN_NAME,
        VALUE:CONCATENATED_TABLE_NAME::STRING AS CONCATENATED_TABLE_NAME,
        VALUE:SQL_DATA_TYPE::STRING AS SQL_DATA_TYPE,
        VALUE:COLUMN_ORDERS::NUMBER AS COLUMN_ORDERS,
        VALUE:IS_NULLABLE::STRING AS IS_NULLABLE,
        VALUE:STG_SCHEMA_NAME::STRING AS STG_SCHEMA_NAME,
        VALUE:STG_TABLE_NAME::STRING AS STG_TABLE_NAME,
        VALUE:STG_DATABASE_NAME::STRING AS STG_DATABASE_NAME,
        VALUE:TARGET_SCHEMA_NAME::STRING AS TARGET_SCHEMA_NAME,
        VALUE:TARGET_TABLE_NAME::STRING AS TARGET_TABLE_NAME,
        VALUE:COMMENTS::STRING AS COMMENTS,
        VALUE:CREATED_BY_NAME::STRING AS CREATED_BY_NAME
    FROM TABLE(FLATTEN(INPUT => :GET_SQL_COLUMNS));


  --- step 6 Conditional logic for FILE_TYPE = ''SQL''
    IF (:FILE_TYPE = ''SQL'') THEN
      
        -- Check if ING_TABLE record exists for FILE_ID
        RECORD_EXISTS := (SELECT CASE WHEN COUNT(*) > 0 THEN TRUE ELSE FALSE END 
        FROM INGESTION_TABLE_SCHEMA WHERE FILE_ID = :FILE_ID );
        
         END IF;
         
    IF (:RECORD_EXISTS = TRUE) THEN

    Existing_column_count := ( SELECT COUNT(*) 
    FROM GET_SQL_COLUMNS_DETAILS
    WHERE CONCATENATED_TABLE_NAME = ( SELECT 
    DISTINCT SUBSTRING(BRONZE_TABLE_NAME, POSITION(''_'' IN BRONZE_TABLE_NAME) + 1) AS EXTRACTED_CODE
    FROM INGESTION_TABLE_SCHEMA WHERE FILE_ID = :FILE_ID ));


        -- Check if any records are present in information_schema.columns for FILE_ID
   COLUMN_COUNT := ( SELECT COUNT(*) 
    FROM information_schema.columns
    WHERE TABLE_NAME =  (SELECT DISTINCT BRONZE_TABLE_NAME FROM INGESTION_TABLE_SCHEMA WHERE FILE_ID =:FILE_ID )
    AND COLUMN_NAME NOT LIKE ''%ELT_%'' );

END IF;


IF (:EXISTING_COLUMN_COUNT != :COLUMN_COUNT) THEN

        -- Insert only new column names into ING_TABLE
   MISSING_COLUMNS  := (
    SELECT LISTAGG (''ADD'' || '' ''  || COLUMN_NAME || '' '' || SQL_DATA_TYPE || '', '' ) 
      WITHIN GROUP (ORDER BY COLUMN_ORDERS)
 FROM GET_SQL_COLUMNS_DETAILS  WHERE CONCATENATED_TABLE_NAME= (SELECT DISTINCT SUBSTRING(BRONZE_TABLE_NAME, POSITION(''_'' IN BRONZE_TABLE_NAME) + 1) AS EXTRACTED_CODE  FROM INGESTION_TABLE_SCHEMA  WHERE FILE_ID = 1 )
        AND COLUMN_NAME NOT IN 
        (
    SELECT  DISTINCT COLUMN_NAME FROM information_schema.columns 
    WHERE TABLE_NAME = (SELECT DISTINCT BRONZE_TABLE_NAME FROM INGESTION_TABLE_SCHEMA 
    WHERE FILE_ID = 1
    AND COLUMN_NAME NOT LIKE ''%ELT_%'' ))) ;
    

 MISSING_COLUMNSS :=  RTRIM(MISSING_COLUMNS,'', '');

 
 INSERT INTO
        INGESTION_TABLE_SCHEMA (
            TABLE_SCHEMA_ID,
            DATABASE_NAME,
            STAGE_TABLE_SCHEMA,
            STAGE_TABLE_NAME,
            BRONZE_SCHEMA_NAME,
            BRONZE_TABLE_NAME,
            FILE_ID,
            COLUMN_NAME,
            COLUMN_DATATYPE_TEXT,
            COLUMN_COMMENT,
            NULLABLE_FLG,
            COLUMN_SEQUENCE_NUMBER,
            COLUMN_START_POSITION_NUMBER,
            COLUMN_END_POSITION_NUMBER,
            CASTING_LOGIC_TEXT,
            CASTING_DATE_FORMAT_TEXT,
            CREATED_BY_NAME,
            CREATED_TS )
            
            SELECT
           TABLE_SCHEMA_ID_SEQ.NEXTVAL,
            STG_DATABASE_NAME,
            STG_SCHEMA_NAME,
            STG_TABLE_NAME,
            TARGET_SCHEMA_NAME,
            TARGET_TABLE_NAME,
            :FILE_ID,
            COLUMN_NAME,
            SQL_DATA_TYPE,
            COMMENTS,
            IS_NULLABLE,
            COLUMN_ORDERS,
            NULL,
            NULL,
            NULL,
            NULL,
            CREATED_BY_NAME,
            CURRENT_TIMESTAMP         
     FROM GET_SQL_COLUMNS_DETAILS
WHERE CONCATENATED_TABLE_NAME= (SELECT DISTINCT SUBSTRING(BRONZE_TABLE_NAME, POSITION(''_'' IN BRONZE_TABLE_NAME) + 1) AS EXTRACTED_CODE  FROM INGESTION_TABLE_SCHEMA  WHERE FILE_ID = 1 )
        AND COLUMN_NAME NOT IN 
        (
    SELECT  COLUMN_NAME FROM information_schema.columns 
    WHERE TABLE_NAME = (SELECT DISTINCT BRONZE_TABLE_NAME FROM INGESTION_TABLE_SCHEMA 
    WHERE FILE_ID = 1
    AND COLUMN_NAME NOT LIKE ''%ELT_%'' )) ;


       
TARGET_TABLE_NAME  := (SELECT DISTINCT BRONZE_TABLE_NAME FROM INGESTION_TABLE_SCHEMA 
    WHERE FILE_ID =:FILE_ID);

TARGET_SCHEMA_NAME := (SELECT DISTINCT BRONZE_SCHEMA_NAME FROM INGESTION_TABLE_SCHEMA 
    WHERE FILE_ID =:FILE_ID);

   -- Step 2: Build the ALTER TABLE Statement
DDL_STATEMENT := ''ALTER TABLE '' || :TARGET_SCHEMA_NAME || ''.'' || :TARGET_TABLE_NAME || '' '' || MISSING_COLUMNSS || '';'';

-- Execute the DDL Statement
EXECUTE IMMEDIATE DDL_STATEMENT;
     
END IF;

 RETURN ''SUCCESS'';
 --res := (select * from GET_SQL_COLUMNS_DETAILS);
 --RETURN table (res);
 
END';